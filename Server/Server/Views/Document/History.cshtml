@model Server.ViewModels.HistoryViewModel
@using System.Collections.Immutable;
@using System.Linq;
@using System.Net;
@using Server.ViewModels;
@using System.Text.Encodings.Web;
@{
    var documentCount = Model.DocumentsInFamily.Count();
    var documentsInOrder = ImmutableArray.CreateRange(Model.DocumentsInFamily.OrderBy(d => d.Timestamp));
    IEnumerable<DocumentListingViewModel> allTips;
    {
        var antecedentSet = ImmutableHashSet.CreateRange(Model.Relations.Select(r => r.AntecedentId));
        allTips = Model.DocumentsInFamily.Where(d => !antecedentSet.Contains(d.Id));
    }

    var documentsInLanes = new HashSet<MD5Sum>();

    var lanes = new List<MutableLane>(allTips.Select(t => new MutableLane(t)));

    for(var i = 0; i < lanes.Count; i++) {
        var lane = lanes[i];
        System.Diagnostics.Debug.Assert(lane.Count() == 1);
        var d = lane.First();
        do {
            System.Diagnostics.Debug.Assert(d != null);
            //Find the singular antecedant. If there are multiple antecedants, they go to new lanes.
            var antecedentIds = Model.Relations.Where(r => r.DescendantId.Equals(d.Id)).Select(r => r.AntecedentId);
            var antecedents = antecedentIds.Select(id => Model.DocumentsInFamily.Single(dl => dl.Id.Equals(id)));
            var next = antecedents.FirstOrDefault(dl => !documentsInLanes.Contains(dl.Id) && dl.AuthorId.Equals(lane.AuthorId));
            foreach(var antecedent in antecedents) {
                if(documentsInLanes.Contains(antecedent.Id)) {
                    //this is already represented
                } else if(antecedent.AuthorId.Equals(lane.AuthorId)) {
                    lane.Add(antecedent);
                } else {
                    lanes.Add(new MutableLane(antecedent));
                }
                documentsInLanes.Add(antecedent.Id);
            }
            d = next;
        } while(d != null);
    }

    var authorIds = Model.DocumentsInFamily.Select(d => d.AuthorId).Distinct().OrderBy(id => id);
    lanes = lanes.OrderBy(l => l.AuthorId).ToList();

    var coords = new Dictionary<MD5Sum,Tuple<float,float>>();

    for(var laneIndex = 0; laneIndex < lanes.Count; laneIndex++) {
        foreach(var d in lanes[laneIndex]) {
            var index = documentsInOrder.IndexOf(d);
            var x = 0.5f + (float) index;
            var y = 0.5f + (float) laneIndex;
            coords[d.Id] = new Tuple<float,float>(x, y);
        }
    }

    const double rowHeightEm = 1.2;
}
<table class="title"><tr>
    <td><h1>@Html.DisplayFor(m => m.Title)</h1></td>
    <td><a asp-action="GetDocument">View</a>
    </td>
</tr></table>
<h2>History</h2>
<table id="history"><tr>
    <td>
        @{{
            var i = 0;
            foreach(var authorId in authorIds) {
                var c = ((i/2)*2 == i) ? "even" : "odd";
                i++;
                var authorDisplayName = Model.DocumentsInFamily.First(d => d.AuthorId.Equals(authorId)).AuthorDisplayName;
                var laneCount = lanes.Count(l => l.AuthorId.Equals(authorId));
                <div class='@(c)' style="height:@(laneCount*rowHeightEm)em;line-height:@(rowHeightEm)">
                    @HtmlEncoder.Default.Encode(authorDisplayName)
                </div>           
            }
        }}
    </td>
    <td>
        <svg width="@(documentCount*rowHeightEm)em" height="@(lanes.Count*rowHeightEm)em" viewBox="0 0 @(documentCount) @(lanes.Count)">
            @{
                var rowOffsetAccumulator = 0;
                for(var i = 0; i < authorIds.Count(); i++) {
                    var a = authorIds.ElementAt(i);
                    var c = ((i/2)*2 == i) ? "even" : "odd";
                    var h = lanes.Count(l => l.AuthorId.Equals(a));
                    rowOffsetAccumulator += h;
                    <rect width="@(documentCount)" y='@(rowOffsetAccumulator-h)' height="@(h)" class="@(c)" />
                }
            }
            @foreach(var r in Model.Relations) {
                var alfa = coords[r.AntecedentId];
                var bravo = coords[r.DescendantId];
                <path d="M @alfa.Item1 @alfa.Item2 C @(alfa.Item1+1) @alfa.Item2, @(bravo.Item1-1) @bravo.Item2 @bravo.Item1 @bravo.Item2" />
            }
            @foreach(var c in coords) {
                <circle class='@(c.Key.Equals(Model.Id) ? "here" : string.Empty)'
                    cx="@(c.Value.Item1)"
                    cy="@(c.Value.Item2)"
                    r="0.25" />
            }
        </svg>
    </td>
</tr></table>
@section scripts {
}