@model Server.ViewModels.HistoryViewModel
@using System.Collections.Immutable;
@using System.Linq;
@using System.Net;
@using Server.ViewModels;
@using System.Text.Encodings.Web;
@{
    var documentCount = Model.DocumentsInFamily.Count();
    var documentsInOrder = ImmutableArray.CreateRange(Model.DocumentsInFamily.OrderBy(d => d.Timestamp));
    IEnumerable<DocumentListingViewModel> allTips;
    {
        var antecedentSet = ImmutableHashSet.CreateRange(Model.Relations.Select(r => r.AntecedentId));
        allTips = Model.DocumentsInFamily.Where(d => !antecedentSet.Contains(d.Id));
    }

    var documentsInLanes = new HashSet<MD5Sum>();

    var lanes = new List<MutableLane>(allTips.Select(t => new MutableLane(t)));

    for(var i = 0; i < lanes.Count; i++) {
        var lane = lanes[i];
        System.Diagnostics.Debug.Assert(lane.Count() == 1);
        var d = lane.First();
        do {
            System.Diagnostics.Debug.Assert(d != null);
            //Find the singular antecedant. If there are multiple antecedants, they go to new lanes.
            var antecedentIds = Model.Relations.Where(r => r.DescendantId.Equals(d.Id)).Select(r => r.AntecedentId);
            var antecedents = antecedentIds.Select(id => Model.DocumentsInFamily.Single(dl => dl.Id.Equals(id)));
            var next = antecedents.FirstOrDefault(dl => !documentsInLanes.Contains(dl.Id) && dl.AuthorId.Equals(lane.AuthorId));
            foreach(var antecedent in antecedents) {
                if(documentsInLanes.Contains(antecedent.Id)) {
                    //this is already represented
                } else if(antecedent.AuthorId.Equals(lane.AuthorId)) {
                    lane.Add(antecedent);
                } else {
                    lanes.Add(new MutableLane(antecedent));
                }
                documentsInLanes.Add(antecedent.Id);
            }
            d = next;
        } while(d != null);
    }

    var authorIds = Model.DocumentsInFamily.Select(d => d.AuthorId).Distinct().OrderBy(id => id);
    lanes = lanes.OrderBy(l => l.AuthorId).ToList();

    var coords = new Dictionary<MD5Sum,Tuple<float,float>>();

    for(var laneIndex = 0; laneIndex < lanes.Count; laneIndex++) {
        foreach(var d in lanes[laneIndex]) {
            var index = documentsInOrder.IndexOf(d);
            var x = 0.5f + (float) index;
            var y = 0.5f + (float) laneIndex;
            coords[d.Id] = new Tuple<float,float>(x, y);
        }
    }

    var isFirstRow = true;
}
<table class="title"><tr>
    <td><h1>@Html.DisplayFor(m => m.Title)</h1></td>
    <td><a asp-action="GetDocument">View</a>
    </td>
</tr></table>
<h2>History</h2>
<table id="history">
    @foreach(var authorId in authorIds) {
        var authorDisplayName = Model.DocumentsInFamily.First(d => d.AuthorId.Equals(authorId)).AuthorDisplayName;
        var laneCount = lanes.Count(l => l.AuthorId.Equals(authorId));
        <tr>
            <th style="height:@(laneCount)em">@HtmlEncoder.Default.Encode(authorDisplayName)</th>
            @if(isFirstRow) {
                isFirstRow = false;
                <td rowspan="@(authorIds.Count())">
                    <svg width="@(documentCount)em" height="@(lanes.Count)em" viewBox="0 0 @(documentCount) @(lanes.Count)">
                        @foreach(var c in coords) {
                            <circle
                                cx="@(c.Value.Item1)"
                                cy="@(c.Value.Item2)"
                                r="0.25" />
                        }
                        @foreach(var r in Model.Relations) {
                            var alfa = coords[r.AntecedentId];
                            var bravo = coords[r.DescendantId];
  <path d="M @alfa.Item1 @alfa.Item2 C @(alfa.Item1+1) @alfa.Item2, @(bravo.Item1-1) @bravo.Item2 @bravo.Item1 @bravo.Item2" />
                        }
                    </svg>
                </td>
            }
        </tr>
    }
</table>
@section scripts {
}